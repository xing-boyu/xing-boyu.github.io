[{"title":"面向对象设计原则-S.O.L.I.D","url":"/2021/12/14/面向对象设计原则SOLID/","content":"面向对象的五大设计原则S.O.L.I.D，应用这些原则可以引导创建出一个更容易维护和扩展性的软件系统。\n\nSOLID释义:\n- S - Single-responsiblity Principle（单一责任原则）\n- O - Open-closed Principle（开闭原则）\n- L - Liskov Substitution Principle（里氏替换原则）\n- I - Interface Segregation Principle（接口隔离原则）\n- D - Dependency Inversion Principle（依赖倒置原则）\n\n## 单一责任原则（SRP）\n单一责任原则：类仅具有单一的功能\n> A class should have one, and only one, reason to change.\n\n### 违背单一责任原则\n![solid1](/img/solid/solid1.png)\n如上是个JDK中Date的类定义，其中定义了Date format的两个方法，假设在这个基础上需要再增加另一种format方法，则需要修改类的定义类似再增加一个方法如下。\n```\npublic String toCustomString() {\n    DateFormat formatter = CustomDateFormat.getDateTimeInstance();\n    return formatter.format(this);\n}\n```\n### 单一责任原则应用\n```\n@deprecated As of JDK version 1.1\nreplaced by DateFormat.format(Date date)\n```\n上面是方法定义上的注释已经废弃了，通过DateFormat.format(Date date)来替代format的功能。后面想扩展任何其他format格式，不用动Date本身的定义，只需要实现DateFormat接口即可以达到功能扩展。\n\n下图是jdk中类似的思想实现，ObjectInputStream在readObjec时需要针对对象进行数据校验，校验通过定义接口ObjectInputValidation供调用方进行扩展出自定义的Validation。\n![solid2](/img/solid/solid2.png)\n\n## 开闭原则原则（OCP）\n开闭原则：软件实体应该对扩展开放对修改关闭。\n> Objects or entities should be open for extension but closed for modification.\n\n### 违背开闭原则\n```\npublic List<User> sort(List<User> users, Enum type){\n    if (type == AGE){\n        // 按年龄排序\n        users = resortListByAge(users);\n    } else if (type == NAME){\n        // 按名称首字母排序\n        users = resortListByName(users);\n    } else if (type == HEALTH){\n        // 按客户健康分排序\n        users = resortListByHealth(users);\n    }\n    return users;\n}\n```\nsort方法根据不同的type进行排序，随着业务发展需要增加一个用户按照体重排序，只能按照如下方式进行修改代码\n```\npublic List<User> sort(List<User> users, Enum type){\n    if (type == AGE){\n        // 按年龄排序\n        users = resortListByAge(users);\n    } else if (type == NAME){\n        // 按名称首字母排序\n        users = resortListByName(users);\n    } else if (type == HEALTH){\n        // 按客户健康分排序\n        users = resortListByHealth(users);\n    } else if (type == WEIGHT) {\n        // 按客户体重排序\n        users = resortListByWeight(users);\n    }\n    return users;\n}\n```\n上述代码就是一个明显违背开闭原则的例子，当我们需要新增一种类型时，需要修改主流程。\n\n### 开闭原则应用\n按照开闭原则对上述代码进行重构，在增加新类型时不需要修改主流程，将需要修改的地方开放给到调用方。\n![solid3](/img/solid/solid3.png)\n增加体重排序逻辑只需要定义WeightComparator实现Comparator。\n```\npublic List<User> sort(List<User> users, Comparator<? super User> c) {\n\t//根据比较符c对users进行排序\n    return users;\n}\n```\n按照体重排序的调用：sort(users, WeightComparator);\n\n下图是JDK中类似的排序实现Arrays.sort。\n![solid4](/img/solid/solid4.png)\n\n## 里氏替换原则（LSP）\n里氏替换原则：程序中的对象应该是可以在不改变程序正确性的前提下被他的子类所替换。\n> Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.\n```\nList<String> arrays = new ArrayList<>();\narrays.add(\"A\");\narrays.add(\"B\");\narrays.add(\"C\");\n```\n\n上面是一段简单的代码，按照里氏替换原则可以被替换为如下代码。\n```\nList<String> arrays = new LinkedList<>();\narrays.add(\"A\");\narrays.add(\"B\");\narrays.add(\"C\");\n\n或者\n\nList<String> arrays = Arrays.asList(\"A\");\narrays.add(\"B\");\narrays.add(\"C\");\n\n或者\n\nList<String> arrays = ImmutableList.copyOf(\"A\");\narrays.add(\"B\");\narrays.add(\"C\");\n```\n第一个替换是符合里氏替换原则没有问题，但是后两个替换不符合预期，替换后编译没有问题，但是在执行时出现运行时异常如下。\n```\njava.lang.UnsupportedOperationException\n\tat java.util.AbstractList.add(AbstractList.java:148)\n\tat java.util.AbstractList.add(AbstractList.java:108)\n```\n往往第一次在开发过程中遇到这个错误会很诧异，为什么会抛出来异常信息，他不是一个List吗？是不是jdk中的包也有不符合里氏替换原则的，严格意义上来说是的。但是我们去看一下List<T>.add接口的定义\n```\n/**\n     * Appends the specified element to the end of this list (optional\n     * operation).\n     *\n     * <p>Lists that support this operation may place limitations on what\n     * elements may be added to this list.  In particular, some\n     * lists will refuse to add null elements, and others will impose\n     * restrictions on the type of elements that may be added.  List\n     * classes should clearly specify in their documentation any restrictions\n     * on what elements may be added.\n     *\n     * @param e element to be appended to this list\n     * @return <tt>true</tt> (as specified by {@link Collection#add})\n     * @throws UnsupportedOperationException if the <tt>add</tt> operation\n     *         is not supported by this list\n     * @throws ClassCastException if the class of the specified element\n     *         prevents it from being added to this list\n     * @throws NullPointerException if the specified element is null and this\n     *         list does not permit null elements\n     * @throws IllegalArgumentException if some property of this element\n     *         prevents it from being added to this list\n     */\n    boolean add(E e);\n```\n他在方法注释上声明了，如果List不支持add操作会抛出UnsupportedOperationException。虽然List<T>.add方法注释上声明了存在List不支持add方法，但是我个人建议编程过程中还是尽量避免这样的方式，会给调用方增加使用成本，得清楚具体的实现类是否有可选方法的实现。\n\n## 接口隔离原则（ISP）\n接口隔离原则：子类中不应该被迫依赖于他们不使用的方法\n>clients should not be forced to implement the unwanted methods of an interface\n\n### 违反接口隔离原则\n```\npublic interface MediaPlayer {\n    public void playAudio();\n    public void playVideo();\n}\n```\n\n```\npublic class VlcMediaPlayer implements MediaPlayer {\n    @Override\n    public void playAudio() {\n        System.out.println(\" Playing audio ..........\");\n\n    }\n\n    @Override\n    public void playVideo() {\n        System.out.println(\" Playing video ..........\");\n\n    }\n}\n```\n```\npublic class WinampMediaPlayer implements MediaPlayer {\n\n    // Play video is not supported in Winamp player\n    public void playVideo() {\n        throw new VideoUnsupportedException();\n    }\n\n    @Override\n    public void playAudio() {\n        System.out.println(\"Playing audio ..............\");\n\n    }\n}\n```\nWinampMediaPlayer不支持playVideo方法，但是其实现了MediaPlayer所以也被迫实现了playVideo方法。\n\n### 接口隔离原则应用\n```\npublic interface AudioMediaPlayer {\n    public void playAudio();\n}\n```\n```\npublic interface VideoMediaPlayer {\n    public void playVideo();\n\n}\n```\n将MediaPlayer接口中的方法按照功能拆分出AudioMediaPlayer、VideoMediaPlayer，只有音频播放能力的播放器只需要实现AudioMediaPlayer。\n```\npublic class VlcMediaPlayer implements VideoMediaPlayer, AudioMediaPlayer {\n\n    @Override\n    public void playVideo() {\n        System.out.println(\" Playing video ..........\");\n\n    }\n\n    @Override\n    public void playAudio() {\n        System.out.println(\" Playing audio ..........\");\n\n    }\n}\n```\n```\npublic class WinampMediaPlayer implements AudioMediaPlayer {\n\n    @Override\n    public void playAudio() {\n        System.out.println(\" Playing audio........\");\n\n    }\n}\n```\nWinampMediaPlayer实现接口AudioMediaPlayer，避免被迫实现playVideo方法。\n\n下图JDK中的双向链表，实现List、Deque两个接口。\n![solid5](/img/solid/solid5.png)\n\n## 依赖倒置原则（DIP）\n依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。\n>High level modules shouldnot depend upon low level modules.Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions\n\n![solid6](/img/solid/solid6.png)\n图中是人去拿起水杯喝水，逻辑上是人依赖于水杯的实现，但是再思考一下，人的手型是确定的，其实是我们在生产水杯的时候适配人的手型去生产的。\n![solid7](/img/solid/solid7.png)\n\n## 总结\nS.O.L.I.D面向对象的设计，能够指导我们去更好的构建容易维护、扩展性搞的系统，几种原则需要反复结合日常开发过程中的一些思考不断强化，逐步理解到运用。\n\n## 参考资料\n[SOLID: The First 5 Principles of Object Oriented Design](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)\n\n[重拾面向对象软件设计​](https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247506304&idx=1&sn=f7dd3f19a7d38489e08dccab70d530d3&chksm=e92ae48fde5d6d99745e659005bb3db5220421180fa993fd961e0d8042af51c4d707dcbb555b#rd)\n","tags":["Design"]},{"title":"Terminal高效办公","url":"/2021/07/03/Terminal高效办公/","content":"作为一位程序员，每天上班就是写BUG -> 写BUG -> 写BUG，下班，oh no~~~BUG还没写完还有脸下班，加班到写不动了再下班。\n\n作为Java程序员虽说很多集成工具已经做的很完善了很多东西都可以通过非常好的集成开发环境来搞定(开发、版本管理等)，ok，其实集成开发环境也不是能完全搞定所有的事情，本地运行日志的Grep等就需要借助终端搞笑完成。还有远程服务出现问题需要登录到远程机器上去看服务的运行状态等。\n\n所以程序员日常接触到终端的机会非常非常的多，那你用的是什么样的终端环境呢？\n\n我一般很懒下个iterm2调调字体背景窗体就用起来了，在团队中还能看到直接用Mac自带的Terminal，当然都能很好的完成日常工作，这里就借助zsh来一步步搭建一个不太华丽的Terminal吧。\n\n### 配置\n- iTerm2\n- Oh-My-Zsh(用来管理zsh的配置有很多主题以及丰富的插件可供使用；zsh是shell外壳，强大的虚拟终端)\n- agnoster 主题\n- zsh 命令语法高亮\n\n### 安装Homebrew\n拿到一台几乎全新的电脑，brew都没有，所以先通过以下命令安装个[Homebrew](https://brew.sh/)\n\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n安装Homebrew的过程中也会安装Xcode Command Line Tools(Git等工具)\n\n### 安装 iTerm2\n安装iTerm2可以从[官方下载](https://www.iterm2.com/)后直接安装\n\n可以说下载了iTerm2就已经比用Mac自带的Terminal迈出了很大一步吗，嘻嘻~~~\n\n### 安装zsh\n一般情况下zsh都是OS X自带安装好的，不需要额外安装\n\n可以通过如下命令来查看zsh是否安装好\n`zsh --version`\n\n如果没有安装好可以通过命令`brew install zsh zsh-completions`进行安装\n\n### 安装 Oh-My-Zsh\n通过以下命令安装Oh-My-Zsh\n```\nsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n### 安装 Powerline fonts\n通过git拉代码下来后进行安装Powerline字体\n```\ngit clone https://github.com/powerline/fonts.git --depth=1; cd fonts; ./install.sh; cd ..; rm -rf fonts\n```\n下载好字体后按如下步骤应用到iterm2中\n\nPreferences -> Profiles -> Text -> Change Font具体配置参考如下图\n\n\n### 安装 agnoster 主题\n一般情况下Oh-My-Zsh安装的时候默认安装了这个主题 可以通过`ls ~/.oh-my-zsh/themes`查看所有的默认主题。\n\n按照如下步骤切换主题\n\n`vim ~/.zshrc`打开配置文件，修改里面 ZSH_THEME 的值为 ZSH_THEME=\"agnoster\"\n\n还有各种主题[点这里](https://github.com/robbyrussell/oh-my-zsh/wiki/Themes#agnoster)\n\n修改命令提示符\n\n应用主题后命令提示符会变得很长 `zhouzhou@zhouzhoudeMacBook` 这样导致显示太过冗长了，因此可以在`vim ~/.zshrc`中追加\n```\n# 注意：DEFAULT_USER 的值必须要是系统用户名才能生效\nDEFAULT_USER=\"user\"\n```\n来去掉冗长的显示\n\n### 安装 zsh-syntax-highlighting 命令高亮插件\n通过如下命令安装自定义的高亮插件\n```\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n```\n安装完成后通过修改`vim ~/.zshrc`中的如下部分，通过执行`source ~/.zshrc`应用高亮插件\n```\nplugins=(\n  git\n  zsh-syntax-highlighting\n)\n```\n\n### 参考\n[Mac OS X 下优化 Terminal，一篇就够了！](https://zhuanlan.zhihu.com/p/41745503)\n\n[iTerm2 + Oh My Zsh 打造舒适终端体验](https://zhuanlan.zhihu.com/p/37195261)\n","tags":["Tool"]}]